> 原文链接：[The difference between NgDoCheck and AsyncPipe in OnPush components](https://blog.angularindepth.com/the-difference-between-ngdocheck-and-asyncpipe-in-onpush-components-4918ec4b29d4)
>
> 原技术博文由`Max Koretskyi`撰写发布，他目前于[ag-Grid](https://angular-grid.ag-grid.com/?utm_source=medium&utm_medium=blog&utm_campaign=angularcustom)担任开发者职位
>
> 译者：[vaanxy](https://github.com/vaanxy)；校对者：暂无



# On Push 组件中NgDoCheck 与 AsyncPipe 的区别

一份关于在Angular中手动控制change detection的深度指南



![img](https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg)

------

本博文是对 [to this tweet by Shai](https://twitter.com/shai_reznik/status/1054868497363283968) 问题的回复。 He asks whether it makes sense to use `NgDoCheck` lifecycle hook to manually compare values instead of using the recommend approach with the `async` pipe.

他想知道何时使用 `NgDoCheck` 这一生命周期钩子函数来手动比较值是否发生的变化更合理，而非使用推荐的 `async` 管道方法。

 That’s a very good question that requires a lot of understanding of how things work under the hood: change detection, pipes and lifecycle hooks. That’s where I come in 😎.

这是个很棒的问题，回答这个问题需要了解很多关于change detection, pipes 以及 lifecycle hooks 相关知识背后的工作原理。我就是为此而来的😎。

In this article I’m going to show you how to manually work with change detection. These techniques give you a finer control over the comparisons performed automatically by Angular for input bindings and async values checks. Once we have this knowledge, I’ll share with you my thoughts on the performance impact of these solutions.



本文我将为大家演示如何去手动操作 change detection。相比 Angular 自动地处理比较 input bindings 以及 async values checks，掌握下文将演示的技巧之后，将能帮助你更好的去控制这些内容。

一旦我们掌握了这些知识，我将会为大家分享一些关于这些解决方案对应用性能影响的个人观点。



> I work as a developer advocate at [ag-Grid](https://angular-grid.ag-grid.com/?utm_source=medium&utm_medium=blog&utm_campaign=angularcustom). If you’re curious to learn about data grids or looking for the ultimate Angular data grid solution, give it a try with the guide “[Get started with Angular grid in 5 minutes](http://blog.ag-grid.com/index.php/2018/08/13/get-started-with-angular-grid-in-5-minutes/?utm_source=medium&utm_medium=blog&utm_campaign=getstartedangular)”. I’m happy to answer any questions you may have. [**And follow me to stay tuned!**](https://twitter.com/maxim_koretskyi)

Let’s get started!

让我们开始吧！

#### **OnPush components**



#### OnPush	组件

In Angular, we have a very common optimization technique that requires adding the `ChangeDetectionStrategy.OnPush` to a component’s decorator. Suppose we have a simple hierarchy of two components like this:



在Angular中，我们有一个非常常见的优化技巧，那就是在组件装饰器中添加上 `ChangeDetectionStrategy.OnPush`。比如我们有如下两个结构简单的组件：



<iframe width="700" height="250" data-src="/media/667767c5c8ffc6cc96d9b3bf25732f37?postId=4918ec4b29d4" data-media-id="667767c5c8ffc6cc96d9b3bf25732f37" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/667767c5c8ffc6cc96d9b3bf25732f37?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 351px;"></iframe>

With this setup, Angular runs change detection always for both `A` and `B`components every single time. If we now add the `OnPush` strategy for the `B`component:



如此配置的话，Angular每次都会对组件`A`和组件`B`进行change detection。如果我们现在为组件`B`添加`OnPush`策略: 



<iframe width="700" height="250" data-src="/media/473ea0200e202d45f3c2272df48dd291?postId=4918ec4b29d4" data-media-id="473ea0200e202d45f3c2272df48dd291" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/473ea0200e202d45f3c2272df48dd291?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 175px;"></iframe>

Angular will run change detection for the `B` component **only if its input bindings have changed**. Since at this point it doesn’t have any bindings, the component will ever only be checked once during the bootstrap.

Angular **仅会在组件`B`的input bindings发生变化时**才对其进行 change detection。尽管现在组件B还没有任何 bindings，组件仅仅会在启动的时候被检查一次。

#### Triggering change detection manually

Is there a way to force change detection on the component `B`? Yes, we can inject `changeDetectorRef` and use its method `markForCheck` to indicate for Angular that this component needs to be checked. And [since the NgDoCheck hook will still be triggered for B component](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5), that’s where we should call the method:

#### 手动触发change detection

我们是否能够强行对组件 `B` 进行change detection? 当然，我们可以通过注入 `changeDetectorRef`  并调用其 `markForCheck` 方法来示意 Angular 这个组件需要被检查一下。并且 [由于组件 B NgDoCheck 钩子函数仍会被触发](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5)，因此我们应当在该钩子函数里调用 `markForCheck` 方法。

<iframe width="700" height="250" data-src="/media/e4d7889703621433c467b426201964d1?postId=4918ec4b29d4" data-media-id="e4d7889703621433c467b426201964d1" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/e4d7889703621433c467b426201964d1?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 306.984px;"></iframe>

Now, the component `B` will always be checked when Angular checks the parent `A` component. Let’s now see where we can use it.

现在，当Angular对组件 `A` 进行检查的时候，组件 `B` 也总是会被检查。 现在让我们看看我们能在哪儿使用它。

#### Input bindings

I told you that Angular only runs change detection for `OnPush` components when bindings change. So let’s see the example with input bindings. Suppose we have an object that is passed down from the parent component through the inputs:

刚才和大家说过，对于 `OnPush` 组件而言，Angular仅在 bindings 发生变化的时候才执行 change detection。让我们来看一下  input bindings 的例子。假设我们有一个对象是从父组件中通过 inputs 传递进来的：



<iframe width="700" height="250" data-src="/media/fdefb6d4a4dd9816c46bfd305b6f2278?postId=4918ec4b29d4" data-media-id="fdefb6d4a4dd9816c46bfd305b6f2278" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/fdefb6d4a4dd9816c46bfd305b6f2278?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 284.984px;"></iframe>

In the parent component `A` we define the object and also implement the `changeName` method that updates the name of the object when a button is clicked:

在其父组件 `A` 中，我们定义了这个对象，同时还是实现了  `changeName`  方法，当鼠标点击按钮时来更新对象的`name`属性：



<iframe width="700" height="250" data-src="/media/606a90332aefe70066e8376cedf4f137?postId=4918ec4b29d4" data-media-id="606a90332aefe70066e8376cedf4f137" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/606a90332aefe70066e8376cedf4f137?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 373px;"></iframe>

If you now [run this example](https://stackblitz.com/edit/angular-kq26qe), after the first change detection you’re going to see the user’s name printed:

```
User name: A
```



如果你 [运行这个例子](https://stackblitz.com/edit/angular-kq26qe)，在首次 change detection 后，你将会看到用户的`name`属性被打印了出来：

~~~User name: A~~~
User name: A
~~~

But when we click on the button and change the name in the callback:

但当我们点击按钮时，并在其回调函数中改变`name`属性的值：

```
changeName() {
    this.user.name = 'B';
}
```

the name is **not updated** on the screen. And we know why, that’s because Angular performs shallow comparison for the input parameters and the reference to the `user` object hasn’t changed. So how can we fix this?

`name`属性并**没有在屏幕上更新**。我们也知道是为什么，Angular对于传入参数而言执行的是浅比对，`user` 对象的引用并没有发生变化。那么我们该怎么修复这个问题呢？

Well, we can manually check the name and trigger change detection when we detect the difference:

我们只需要手动检查比对 `name` 属性，当发现 `name` 的值发生变化时手动触发 change detection：



<iframe width="700" height="250" data-src="/media/95c44617d5e893b073ebafed609adfd7?postId=4918ec4b29d4" data-media-id="95c44617d5e893b073ebafed609adfd7" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/95c44617d5e893b073ebafed609adfd7?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 505px;"></iframe>

If you now [run this code](https://stackblitz.com/edit/angular-8dkwct), you’re going to see the name updated on the screen.

现在再[执行这段代码](https://stackblitz.com/edit/angular-8dkwct)，你会发现屏幕上的名字被更新了。

#### Asynchronous updates

#### 异步更新

Now, let’s make our example a bit more complex. We’re going to introduce an RxJs based service that emits updates asynchronously. This is similar to what you have in NgRx based architectures. I’m going to use a `BehaviorSubject` as a source of values because I need to start the stream with an initial value:

现在，让我们的例子更复杂些。我们将引入基于RxJS的服务，并通过他来实现异步更新。这和NgRx的架构师类似的。我将使用 `BehaviorSubject` 作为数据源，因为我想要启动流的时候能有一个初始值：



<iframe width="700" height="250" data-src="/media/0cc506e8da02ccb5f97a1ccba562afcc?postId=4918ec4b29d4" data-media-id="0cc506e8da02ccb5f97a1ccba562afcc" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/0cc506e8da02ccb5f97a1ccba562afcc?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 395px;"></iframe>

So we receive this stream of `user` objects in the child component. We need to subscribe to the stream and check if the values are updated. And the common approach to doing that is to use [Async pipe](https://angular.io/api/common/AsyncPipe).



所以我们可以在子组件中接受到该  `user`  对象流。我们需要订阅这个流，并检查值是否被更新了。最常用的方法就是使用 [Async pipe](https://angular.io/api/common/AsyncPipe)。

#### Async pipe

So here’s the implementation of the child `B` component:

下面是子组件 `B` 的实现：



<iframe width="700" height="250" data-src="/media/991ca92b4f02b3389e8d7359ff441f3f?postId=4918ec4b29d4" data-media-id="991ca92b4f02b3389e8d7359ff441f3f" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/991ca92b4f02b3389e8d7359ff441f3f?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 284.984px;"></iframe>

[Here’s the demo](https://stackblitz.com/edit/angular-q8n3qj). But is there another way that doesn't use the pipe?

[这里是 demo](https://stackblitz.com/edit/angular-q8n3qj)。但有没有不使用管道的方法呢？



#### Manual check and change detection

#### 手动检查以及 change detection

Yes, we can check the value manually and trigger change detection if needed. Just as with the examples in the beginning, we can use `NgDoCheck` lifecycle hook for that:



是的，我们可以手动检查值的变化并在需要的时候触发 change detection。就和最一开始的示例一样，我们可以像这样使用 `NgDoCheck` 生命周期钩子函数：



<iframe width="700" height="250" data-src="/media/b7934c27d36c73a981ce1f1fbaef24a6?postId=4918ec4b29d4" data-media-id="b7934c27d36c73a981ce1f1fbaef24a6" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/b7934c27d36c73a981ce1f1fbaef24a6?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 659px;"></iframe>

You can [play with it here](https://stackblitz.com/edit/angular-4xuug1).

你可以[在这儿进行尝试](https://stackblitz.com/edit/angular-4xuug1)。

Ideally, though, we would want to move our comparison and update logic from `NgDoCheck` and put it into the subscription callback, because that’s when the new value will be available:

理想的情况下，尽管，我们想要将比较与更新的逻辑从`NgDoCheck`移至subscription的回调函数中，因为，我们是从那里获取到新的值的：

<iframe width="700" height="250" data-src="/media/09199c5fb82c9e1bc3291f48299511eb?postId=4918ec4b29d4" data-media-id="09199c5fb82c9e1bc3291f48299511eb" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/09199c5fb82c9e1bc3291f48299511eb?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 373px;"></iframe>

[在这儿进行尝试](https://stackblitz.com/edit/angular-lvtfve).

What’s interesting is that it’s exactly what the [Async pipe is doing under the hood](https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139):

但有趣的是，这也正是 [Async pipe背后的工作原理](https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139):

<iframe width="700" height="250" data-src="/media/9579cc67bd8a96373cb6e7684820b379?postId=4918ec4b29d4" data-media-id="9579cc67bd8a96373cb6e7684820b379" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/9579cc67bd8a96373cb6e7684820b379?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 703px;"></iframe>

------

### So which solution is faster?

#### 那个解决方案更快呢？

So now that we know how we can use manual change detection instead of the async pipe, let’s answer the question we started with. Who’s faster?



既然现在我们知道如何手动执行 change detection 来替代 async pipe，让我们来回答一下最一开始的问题，哪一种方式更快？

Well, it depends on how you compare them, but with everything else being equal, manual approach is going to be faster. I don’t think though that the difference will be tangible. Here are just a few examples why manual approach can be faster. 

嗯，这取决于你怎么比较他们，在其他条件都一样时，手动方法会更快，尽管我不认为能看出明显的区别。一下几个例子会说明为什么手动方法更快。

In terms of memory you don’t need to create an instance of a Pipe class. In terms of compilation time the compiler doesn’t have to spend time parsing pipe specific syntax and generating pipe specific output. In terms of runtime, you save yourself a couple of function calls for each change detection run on the component with async pipe. Here’s for example the code for the [updateRenderer](https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d) function generated for the code with pipe:



从内存的角度考虑，你不需要创建一个Pipe class的实例。从编译时间角度来看，编译器不需要花时间去解析pipe的特有语法并生成pipe的特有输出。从运行时角度看，在每次执行 change detection 时，你省去了在组件中使用async pipe时发生的一堆的函数调用。这里的示例代码演示了 当代码中包含 pipe时 [updateRenderer](https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d) 所生成的代码:



<iframe width="700" height="250" data-src="/media/59cd6105ef1ea9e9c76b838af63c2980?postId=4918ec4b29d4" data-media-id="59cd6105ef1ea9e9c76b838af63c2980" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/59cd6105ef1ea9e9c76b838af63c2980?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 152.984px;"></iframe>

As you can see, the code for the async pipe calls the `transform` method on the pipe instance to get the new value. The pipe is going to return the latest value it received from the subscription.

Compare it to the plain code generated for the manual approach:



正如你所见，async pipe 代码中每个pipe实例都要调用 `transform` 函数来获取新的值。pipe将会返回从订阅（subscription）中获取的最新的值。

将 async pipe 的代码与手动方法生成的代码相比：

<iframe width="700" height="250" data-src="/media/a0c03d33e3e9f714d92c4600dbb6e1dd?postId=4918ec4b29d4" data-media-id="a0c03d33e3e9f714d92c4600dbb6e1dd" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/a0c03d33e3e9f714d92c4600dbb6e1dd?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 152.984px;"></iframe>

These are the functions executed by Angular when checking `B` component.

这些事 Angular 检查组件 `B` 时所执行的函数。

### A few more interesting things

### 一些更有趣的事

Unlike input bindings that perform shallow comparison, **the async pipe**implementation **doesn’t perform comparison at all** (kudos to [Olena Horal](https://medium.com/@sharlatenok)for noticing that). It treats every new emission as an update even if it matches the previously emitted value. Here’s the implementation of the parent component `A` that emits the same object. Despite this fact, Angular still runs change detection for the component `B`:

与 input bindings 的浅比较不同， **async pipe ** 的实现 **完全没有进行比较** (感谢 [Olena Horal](https://medium.com/@sharlatenok) 的提醒). 

<iframe width="700" height="250" data-src="/media/18ae50a24d5744b44f7e07ca95034549?postId=4918ec4b29d4" data-media-id="18ae50a24d5744b44f7e07ca95034549" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/18ae50a24d5744b44f7e07ca95034549?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 219px;"></iframe>

It means that the component with the async pipe will be **marked for check every time a new value is emitted**. And Angular will check the component next time it runs change detection even if the value hasn’t changed.



这意味着使用了 async pipe 的组件**每次产生新的值都会被标记成需要被检查**。 那么无论值是否发生改变，Angular 在下次执行 change detection 都将会对该组件做检查。

Where is this relevant? Well, in our case we’re only interested in the property `name` from the `user` object because we use it in the template. We don’t really care about the whole object and the fact that the reference to the object may change. If the name is the same we don’t need to re-render the component. But you can’t avoid that with the async pipe.

这与什么相关呢？在我们的例子中，我们只关心 `user` 对象的 `name` 属性，因为我们会在模板中用到它。我们并不关心这整个对象，并且实际上该对象的引用可能会发生变化。但如果 `name` 属性事一致的，我们没有必要再次渲染组件。但是你使用 async pipe 就无法避免了。



`NgDoCheck` is not without the problems on its own :) As the hook is only triggered if the parent component is checked, it won’t be triggered if one of its parent components uses `OnPush` strategy and is not checked during change detection. So you can’t rely on it to trigger change detection when you receive a new value through a service. In this case, the solution I showed with putting `markForCheck` in the subscription callback is the way to go.

`NgDoCheck` 本身也有这个问题 :) 由于该钩子函数只有当父组件被检查之后才会触发，而当其任意一个父组件使用了 `OnPush` 策略，并且没有在 change detection 时进行检查，那么这个钩子函数也不会被触发。 所以当从服务中接受到新值时，你并不能依赖他来触发 change detection。 在本例中，我所演示的将 `markForCheck` 方法放在subscription的回调函数中是正确的解决方法。

### Conclusion

### 总结

Basically, manual comparison gives you more control over the check. You can define when the component needs to be checked. And this is the same as with many other tools — manual control gives you more flexibility, but you have to know what you’re doing. And to acquire this knowledge, I encourage you to invest time and effort in learning and [reading sources](https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630).

If you’re concerned with how often `NgDoCheck` lifecycle hook is called or that it’s going to be called more often than the pipe’s `transform` — don’t. First, I showed the solution above where you don’t use the hook in the manual approach with asynchronous stream. Second, the hook will only be called when the parent component is checked. If the parent component is not checked, the hook is not called. And with regards to the pipe, because of the shallow check and changing references in the stream, you’re going to have the same number of calls or even more with the `transform` method of the pipe.

#### Want to learn more about change detection in Angular?

Start with [These 5 articles will make you an Angular Change Detection expert](https://blog.angularindepth.com/these-5-articles-will-make-you-an-angular-change-detection-expert-ed530d28930). This series is a must-read if you want to have a solid grasp of the change detection mechanism in Angular. Each article builds upon the information explained in the preceding one and goes from high-level overview down to implementation details with references to the sources.

### For more insights follow me on [Twitter](https://twitter.com/maxim_koretskyi) and on [Medium](https://medium.com/@maxim.koretskyi).