> åŸæ–‡é“¾æ¥ï¼š[The difference between NgDoCheck and AsyncPipe in OnPush components](https://blog.angularindepth.com/the-difference-between-ngdocheck-and-asyncpipe-in-onpush-components-4918ec4b29d4)
>
> åŸæŠ€æœ¯åšæ–‡ç”±`Max Koretskyi`æ’°å†™å‘å¸ƒï¼Œä»–ç›®å‰äº[ag-Grid](https://angular-grid.ag-grid.com/?utm_source=medium&utm_medium=blog&utm_campaign=angularcustom)æ‹…ä»»å¼€å‘è€…èŒä½
>
> è¯‘è€…ï¼š[vaanxy](https://github.com/vaanxy)ï¼›æ ¡å¯¹è€…ï¼šæš‚æ— 



# On Push ç»„ä»¶ä¸­NgDoCheck ä¸ AsyncPipe çš„ä¸åŒä¹‹å¤„

ä¸€ä»½å…³äºåœ¨Angularä¸­æ‰‹åŠ¨æ§åˆ¶ change detection çš„æ·±åº¦æŒ‡å—



![img](https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg)

------

æœ¬åšæ–‡æ˜¯ [å¯¹ Shai æ¨æ–‡](https://twitter.com/shai_reznik/status/1054868497363283968) é—®é¢˜çš„å›å¤ã€‚ 

He asks whether it makes sense to use `NgDoCheck` lifecycle hook to manually compare values instead of using the recommend approach with the `async` pipe.

ä»–æƒ³çŸ¥é“ä½•æ—¶ä½¿ç”¨ `NgDoCheck` è¿™ä¸€ç”Ÿå‘½å‘¨æœŸé’©å­å‡½æ•°æ¥æ‰‹åŠ¨æ¯”è¾ƒå€¼çš„å˜åŒ–ï¼Œè€Œéä½¿ç”¨æ¨èçš„ `async` ç®¡é“æ–¹æ³•ã€‚

 Thatâ€™s a very good question that requires a lot of understanding of how things work under the hood: change detection, pipes and lifecycle hooks. Thatâ€™s where I come in ğŸ˜.

è¿™æ˜¯ä¸ªå¾ˆæ£’çš„é—®é¢˜ï¼Œå›ç­”è¿™ä¸ªé—®é¢˜éœ€è¦äº†è§£å¾ˆå¤šå…³äº change detection, pipes ä»¥åŠ lifecycle hooks ç›¸å…³çŸ¥è¯†èƒŒåçš„å·¥ä½œåŸç†ã€‚æˆ‘å°±æ˜¯ä¸ºæ­¤è€Œæ¥çš„ğŸ˜ã€‚

In this article Iâ€™m going to show you how to manually work with change detection. These techniques give you a finer control over the comparisons performed automatically by Angular for input bindings and async values checks. Once we have this knowledge, Iâ€™ll share with you my thoughts on the performance impact of these solutions.



æœ¬æ–‡æˆ‘å°†ä¸ºå¤§å®¶æ¼”ç¤ºå¦‚ä½•å»æ‰‹åŠ¨æ“ä½œ change detectionã€‚ç›¸æ¯” Angular è‡ªåŠ¨åœ°å¤„ç†æ¯”è¾ƒ input bindings ä»¥åŠ async values checksï¼ŒæŒæ¡ä¸‹æ–‡å°†æ¼”ç¤ºçš„æŠ€å·§ä¹‹åï¼Œå°†èƒ½å¸®åŠ©ä½ æ›´å¥½çš„å»æ§åˆ¶è¿™äº›å†…å®¹ã€‚

ä¸€æ—¦æˆ‘ä»¬æŒæ¡äº†è¿™äº›çŸ¥è¯†ï¼Œæˆ‘å°†ä¼šä¸ºå¤§å®¶åˆ†äº«ä¸€äº›å…³äºè¿™äº›è§£å†³æ–¹æ¡ˆå¯¹åº”ç”¨æ€§èƒ½å½±å“çš„ä¸ªäººè§‚ç‚¹ã€‚



> æˆ‘åœ¨ [ag-Grid](https://angular-grid.ag-grid.com/?utm_source=medium&utm_medium=blog&utm_campaign=angularcustom) æ‹…ä»»å¼€å‘è€…èŒä½ã€‚å¦‚æœä½ å¯¹ data grids å¾ˆæ„Ÿå…´è¶£ï¼Œæˆ–è€…ä½ åœ¨å¯»æ‰¾Angular ä¸­ data grid çš„ç»ˆæè§£å†³æ–¹æ¡ˆï¼Œè·Ÿç€æœ¬æŒ‡å—"[Get started with Angular grid in 5 minutes](http://blog.ag-grid.com/index.php/2018/08/13/get-started-with-angular-grid-in-5-minutes/?utm_source=medium&utm_medium=blog&utm_campaign=getstartedangular)"æ¥å°è¯•ä¸‹ag-gridå§ã€‚å¦‚æœä½ ä»¬æœ‰ä»»ä½•é—®é¢˜ï¼Œæˆ‘å¾ˆé«˜å…´ä¸ºå¤§å®¶è§£ç­”ã€‚ [**æ•¬è¯·å…³æ³¨æˆ‘çš„æœ€æ–°åŠ¨æ€!**](https://twitter.com/maxim_koretskyi)



è®©æˆ‘ä»¬å¼€å§‹å§ï¼

#### **OnPush components**

#### OnPush	ç»„ä»¶

In Angular, we have a very common optimization technique that requires adding the `ChangeDetectionStrategy.OnPush` to a componentâ€™s decorator. Suppose we have a simple hierarchy of two components like this:

åœ¨Angularä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªéå¸¸å¸¸è§çš„ä¼˜åŒ–æŠ€å·§ï¼Œé‚£å°±æ˜¯åœ¨ç»„ä»¶è£…é¥°å™¨ä¸­æ·»åŠ ä¸Š `ChangeDetectionStrategy.OnPush`ã€‚æ¯”å¦‚æˆ‘ä»¬æœ‰å¦‚ä¸‹ä¸¤ä¸ªç»“æ„ç®€å•çš„ç»„ä»¶ï¼š

~~~typescript
@Component({
    selector: 'a-comp',
    template: `
        <span>I am A component</span>
        <b-comp></b-comp>
    `
})
export class AComponent {}

@Component({
    selector: 'b-comp',
    template: `<span>I am B component</span>`
})
export class BComponent {}
~~~

With this setup, Angular runs change detection always for both `A` and `B`components every single time. If we now add the `OnPush` strategy for the `B`component:

æŒ‰ç…§ä¸Šè¿°æ–¹æ³•è¿›è¡Œé…ç½®ï¼ŒAngularæ¯æ¬¡éƒ½ä¼šå¯¹ç»„ä»¶ `A` å’Œç»„ä»¶ `B` è¿›è¡Œchange detectionã€‚å¦‚æœæˆ‘ä»¬ç°åœ¨ä¸ºç»„ä»¶`B`æ·»åŠ `OnPush`ç­–ç•¥: 

~~~

Angular will run change detection for the `B` component **only if its input bindings have changed**. Since at this point it doesnâ€™t have any bindings, the component will ever only be checked once during the bootstrap.

Angular **ä»…ä¼šåœ¨ç»„ä»¶ `B` çš„ input bindings å‘ç”Ÿå˜åŒ–æ—¶**æ‰å¯¹å…¶è¿›è¡Œ change detectionã€‚å°½ç®¡ç°åœ¨ç»„ä»¶Bè¿˜æ²¡æœ‰ä»»ä½• bindingsï¼Œç»„ä»¶ä»…ä»…ä¼šåœ¨å¯åŠ¨çš„æ—¶å€™è¢«æ£€æŸ¥ä¸€æ¬¡ã€‚

#### Triggering change detection manually

Is there a way to force change detection on the component `B`? Yes, we can inject `changeDetectorRef` and use its method `markForCheck` to indicate for Angular that this component needs to be checked. And [since the NgDoCheck hook will still be triggered for B component](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5), thatâ€™s where we should call the method:

#### æ‰‹åŠ¨è§¦å‘change detection

æˆ‘ä»¬æ˜¯å¦èƒ½å¤Ÿå¼ºè¡Œå¯¹ç»„ä»¶ `B` è¿›è¡Œchange detection? å½“ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ³¨å…¥ `changeDetectorRef`  å¹¶è°ƒç”¨å…¶ `markForCheck` æ–¹æ³•æ¥ç¤ºæ„ Angular è¿™ä¸ªç»„ä»¶éœ€è¦è¢«æ£€æŸ¥ä¸€ä¸‹ã€‚å¹¶ä¸” [ç”±äºç»„ä»¶ B NgDoCheck é’©å­å‡½æ•°ä»ä¼šè¢«è§¦å‘](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5)ï¼Œå› æ­¤æˆ‘ä»¬åº”å½“åœ¨è¯¥é’©å­å‡½æ•°é‡Œè°ƒç”¨ `markForCheck` æ–¹æ³•ã€‚

â€‹~~~typescript
@Component({
    selector: 'b-comp',
    template: `<span>I am B component</span>`,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    constructor(private cd: ChangeDetectorRef) {}

    ngDoCheck() {
        this.cd.markForCheck();
    }
}
~~~

Now, the component `B` will always be checked when Angular checks the parent `A` component. Letâ€™s now see where we can use it.

ç°åœ¨ï¼Œå½“Angularå¯¹ç»„ä»¶ `A` è¿›è¡Œæ£€æŸ¥çš„æ—¶å€™ï¼Œç»„ä»¶ `B` ä¹Ÿæ€»æ˜¯ä¼šè¢«æ£€æŸ¥ã€‚ ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬èƒ½åœ¨å“ªå„¿ä½¿ç”¨å®ƒã€‚

#### Input bindings

I told you that Angular only runs change detection for `OnPush` components when bindings change. So letâ€™s see the example with input bindings. Suppose we have an object that is passed down from the parent component through the inputs:

åˆšæ‰å’Œå¤§å®¶è¯´è¿‡ï¼Œå¯¹äº `OnPush` ç»„ä»¶è€Œè¨€ï¼ŒAngularä»…åœ¨ bindings å‘ç”Ÿå˜åŒ–çš„æ—¶å€™æ‰æ‰§è¡Œ change detectionã€‚è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹  input bindings çš„ä¾‹å­ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå¯¹è±¡æ˜¯ä»çˆ¶ç»„ä»¶ä¸­é€šè¿‡ inputs ä¼ é€’è¿›æ¥çš„ï¼š



~~~typescript

@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{user.name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input() user;
}
~~~



In the parent component `A` we define the object and also implement the `changeName` method that updates the name of the object when a button is clicked:

åœ¨å…¶çˆ¶ç»„ä»¶ `A` ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†è¿™ä¸ªå¯¹è±¡ï¼ŒåŒæ—¶è¿˜æ˜¯å®ç°äº†  `changeName`  æ–¹æ³•ï¼Œå½“é¼ æ ‡ç‚¹å‡»æŒ‰é’®æ—¶æ¥æ›´æ–°å¯¹è±¡çš„`name`å±æ€§ï¼š

~~~typescript
@Component({
    selector: 'a-comp',
    template: `
        <span>I am A component</span>
        <button (click)="changeName()">Trigger change detection</button>
        <b-comp [user]="user"></b-comp>
    `
})
export class AComponent {
    user = {name: 'A'};

    changeName() {
        this.user.name = 'B';
    }
}
~~~

If you now [run this example](https://stackblitz.com/edit/angular-kq26qe), after the first change detection youâ€™re going to see the userâ€™s name printed:

```
User name: A
```



å¦‚æœä½  [è¿è¡Œè¿™ä¸ªä¾‹å­](https://stackblitz.com/edit/angular-kq26qe)ï¼Œåœ¨é¦–æ¬¡ change detection åï¼Œä½ å°†ä¼šçœ‹åˆ°ç”¨æˆ·çš„`name`å±æ€§è¢«æ‰“å°äº†å‡ºæ¥ï¼š

~~~User name: A~~~
User name: A
~~~

But when we click on the button and change the name in the callback:

ä½†å½“æˆ‘ä»¬ç‚¹å‡»æŒ‰é’®æ—¶ï¼Œå¹¶åœ¨å…¶å›è°ƒå‡½æ•°ä¸­æ”¹å˜`name`å±æ€§çš„å€¼ï¼š

```js
changeName() {
    this.user.name = 'B';
}
```

the name is **not updated** on the screen. And we know why, thatâ€™s because Angular performs shallow comparison for the input parameters and the reference to the `user` object hasnâ€™t changed. So how can we fix this?

`name`å±æ€§å¹¶**æ²¡æœ‰åœ¨å±å¹•ä¸Šæ›´æ–°**ã€‚æˆ‘ä»¬ä¹ŸçŸ¥é“æ˜¯ä¸ºä»€ä¹ˆï¼ŒAngularå¯¹äºä¼ å…¥å‚æ•°è€Œè¨€æ‰§è¡Œçš„æ˜¯æµ…æ¯”å¯¹ï¼Œ`user` å¯¹è±¡çš„å¼•ç”¨å¹¶æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚é‚£ä¹ˆæˆ‘ä»¬è¯¥æ€ä¹ˆä¿®å¤è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ

Well, we can manually check the name and trigger change detection when we detect the difference:

æˆ‘ä»¬åªéœ€è¦æ‰‹åŠ¨æ£€æŸ¥æ¯”å¯¹ `name` å±æ€§ï¼Œå½“å‘ç° `name` çš„å€¼å‘ç”Ÿå˜åŒ–æ—¶æ‰‹åŠ¨è§¦å‘ change detectionï¼š



~~~typescript
@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{user.name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input() user;
    previousName = '';

    constructor(private cd: ChangeDetectorRef) {}

    ngDoCheck() {
        if (this.previousName !== this.user.name) {
            this.previousName = this.user.name;
            this.cd.markForCheck();
        }
    }
}
~~~



If you now [run this code](https://stackblitz.com/edit/angular-8dkwct), youâ€™re going to see the name updated on the screen.

ç°åœ¨å†[æ‰§è¡Œè¿™æ®µä»£ç ](https://stackblitz.com/edit/angular-8dkwct)ï¼Œä½ ä¼šå‘ç°å±å¹•ä¸Šçš„åå­—è¢«æ›´æ–°äº†ã€‚

#### Asynchronous updates

#### å¼‚æ­¥æ›´æ–°

Now, letâ€™s make our example a bit more complex. Weâ€™re going to introduce an RxJs based service that emits updates asynchronously. This is similar to what you have in NgRx based architectures. Iâ€™m going to use a `BehaviorSubject` as a source of values because I need to start the stream with an initial value:

ç°åœ¨ï¼Œè®©æˆ‘ä»¬çš„ä¾‹å­æ›´å¤æ‚äº›ã€‚æˆ‘ä»¬å°†å¼•å…¥åŸºäºRxJSçš„æœåŠ¡ï¼Œå¹¶é€šè¿‡ä»–æ¥å®ç°å¼‚æ­¥æ›´æ–°ã€‚è¿™å’ŒNgRxçš„æ¶æ„å¸ˆç±»ä¼¼çš„ã€‚æˆ‘å°†ä½¿ç”¨ `BehaviorSubject` ä½œä¸ºæ•°æ®æºï¼Œå› ä¸ºæˆ‘æƒ³è¦å¯åŠ¨æµçš„æ—¶å€™èƒ½æœ‰ä¸€ä¸ªåˆå§‹å€¼ï¼š

~~~typescript

@Component({
    selector: 'a-comp',
    template: `
        <span>I am A component</span>
        <button (click)="changeName()">Trigger change detection</button>
        <b-comp [user]="user"></b-comp>
    `
})
export class AComponent {
    stream = new BehaviorSubject({name: 'A'});
    user = this.stream.asObservable();

    changeName() {
        this.stream.next({name: 'B'});
    }
}
~~~



So we receive this stream of `user` objects in the child component. We need to subscribe to the stream and check if the values are updated. And the common approach to doing that is to use [Async pipe](https://angular.io/api/common/AsyncPipe).



æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨å­ç»„ä»¶ä¸­æ¥å—åˆ°è¯¥  `user`  å¯¹è±¡æµã€‚æˆ‘ä»¬éœ€è¦è®¢é˜…è¿™ä¸ªæµï¼Œå¹¶æ£€æŸ¥å€¼æ˜¯å¦è¢«æ›´æ–°äº†ã€‚æœ€å¸¸ç”¨çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ [Async pipe](https://angular.io/api/common/AsyncPipe)ã€‚

#### Async pipe

So hereâ€™s the implementation of the child `B` component:

ä¸‹é¢æ˜¯å­ç»„ä»¶ `B` çš„å®ç°ï¼š

~~~typescript

@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{(user | async).name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input() user;
}
~~~

[Hereâ€™s the demo](https://stackblitz.com/edit/angular-q8n3qj). But is there another way that doesn't use the pipe?

[è¿™é‡Œæ˜¯ demo](https://stackblitz.com/edit/angular-q8n3qj)ã€‚ä½†æœ‰æ²¡æœ‰ä¸ä½¿ç”¨ç®¡é“çš„æ–¹æ³•å‘¢ï¼Ÿ



#### Manual check and change detection

#### æ‰‹åŠ¨æ£€æŸ¥ä»¥åŠ change detection

Yes, we can check the value manually and trigger change detection if needed. Just as with the examples in the beginning, we can use `NgDoCheck` lifecycle hook for that:



æ˜¯çš„ï¼Œæˆ‘ä»¬å¯ä»¥æ‰‹åŠ¨æ£€æŸ¥å€¼çš„å˜åŒ–å¹¶åœ¨éœ€è¦çš„æ—¶å€™è§¦å‘ change detectionã€‚å°±å’Œæœ€ä¸€å¼€å§‹çš„ç¤ºä¾‹ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥åƒè¿™æ ·ä½¿ç”¨ `NgDoCheck` ç”Ÿå‘½å‘¨æœŸé’©å­å‡½æ•°ï¼š

~~~typescript
@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{user.name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input('user') user$;
    user;
    previousName = '';

    constructor(private cd: ChangeDetectorRef) {}

    ngOnInit() {
        this.user$.subscribe((user) => {
            this.user = user;
        })
    }

    ngDoCheck() {
        if (this.previousName !== this.user.name) {
            this.previousName = this.user.name;
            this.cd.markForCheck();
        }
    }
}
~~~



You can [play with it here](https://stackblitz.com/edit/angular-4xuug1).

ä½ å¯ä»¥[åœ¨è¿™å„¿è¿›è¡Œå°è¯•](https://stackblitz.com/edit/angular-4xuug1)ã€‚

Ideally, though, we would want to move our comparison and update logic from `NgDoCheck` and put it into the subscription callback, because thatâ€™s when the new value will be available:

ç†æƒ³çš„æƒ…å†µä¸‹ï¼Œå°½ç®¡ï¼Œæˆ‘ä»¬æƒ³è¦å°†æ¯”è¾ƒä¸æ›´æ–°çš„é€»è¾‘ä»`NgDoCheck`ç§»è‡³subscriptionçš„å›è°ƒå‡½æ•°ä¸­ï¼Œå› ä¸ºï¼Œæˆ‘ä»¬æ˜¯ä»é‚£é‡Œè·å–åˆ°æ–°çš„å€¼çš„ï¼š



~~~typescript
export class BComponent {
    @Input('user') user$;
    user = {name: null};

    constructor(private cd: ChangeDetectorRef) {}

    ngOnInit() {
        this.user$.subscribe((user) => {
            if (this.user.name !== user.name) {
                this.cd.markForCheck();
                this.user = user;
            }
        })
    }
}
~~~



<iframe width="700" height="250" data-src="/media/09199c5fb82c9e1bc3291f48299511eb?postId=4918ec4b29d4" data-media-id="09199c5fb82c9e1bc3291f48299511eb" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/09199c5fb82c9e1bc3291f48299511eb?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 373px;"></iframe>

[åœ¨è¿™å„¿è¿›è¡Œå°è¯•](https://stackblitz.com/edit/angular-lvtfve).

Whatâ€™s interesting is that itâ€™s exactly what the [Async pipe is doing under the hood](https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139):

ä½†æœ‰è¶£çš„æ˜¯ï¼Œè¿™ä¹Ÿæ­£æ˜¯ [Async pipeèƒŒåçš„å·¥ä½œåŸç†](https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139):



~~~typescript
@Pipe({name: 'async', pure: false})
export class AsyncPipe implements OnDestroy, PipeTransform {
  constructor(private _ref: ChangeDetectorRef) {}

  transform(obj: ...): any {
    ...
    this._subscribe(obj);

    ...
    if (this._latestValue === this._latestReturnedValue) {
      return this._latestReturnedValue;
    }

    this._latestReturnedValue = this._latestValue;
    return WrappedValue.wrap(this._latestValue);
  }

  private _subscribe(obj): void {
    ...
    this._strategy.createSubscription(
        obj, (value: Object) => this._updateLatestValue(obj, value));
  }

  private _updateLatestValue(async: any, value: Object): void {
    if (async === this._obj) {
      this._latestValue = value;
      this._ref.markForCheck();
    }
  }
}
~~~

------

### So which solution is faster?

#### é‚£ä¸ªè§£å†³æ–¹æ¡ˆæ›´å¿«å‘¢ï¼Ÿ

So now that we know how we can use manual change detection instead of the async pipe, letâ€™s answer the question we started with. Whoâ€™s faster?



æ—¢ç„¶ç°åœ¨æˆ‘ä»¬çŸ¥é“å¦‚ä½•æ‰‹åŠ¨æ‰§è¡Œ change detection æ¥æ›¿ä»£ async pipeï¼Œè®©æˆ‘ä»¬æ¥å›ç­”ä¸€ä¸‹æœ€ä¸€å¼€å§‹çš„é—®é¢˜ï¼Œå“ªä¸€ç§æ–¹å¼æ›´å¿«ï¼Ÿ

Well, it depends on how you compare them, but with everything else being equal, manual approach is going to be faster. I donâ€™t think though that the difference will be tangible. Here are just a few examples why manual approach can be faster. 

å—¯ï¼Œè¿™å–å†³äºä½ æ€ä¹ˆæ¯”è¾ƒä»–ä»¬ï¼Œåœ¨å…¶ä»–æ¡ä»¶éƒ½ä¸€æ ·æ—¶ï¼Œæ‰‹åŠ¨æ–¹æ³•ä¼šæ›´å¿«ï¼Œå°½ç®¡æˆ‘ä¸è®¤ä¸ºèƒ½çœ‹å‡ºæ˜æ˜¾çš„åŒºåˆ«ã€‚ä¸€ä¸‹å‡ ä¸ªä¾‹å­ä¼šè¯´æ˜ä¸ºä»€ä¹ˆæ‰‹åŠ¨æ–¹æ³•æ›´å¿«ã€‚

In terms of memory you donâ€™t need to create an instance of a Pipe class. In terms of compilation time the compiler doesnâ€™t have to spend time parsing pipe specific syntax and generating pipe specific output. In terms of runtime, you save yourself a couple of function calls for each change detection run on the component with async pipe. Hereâ€™s for example the code for the [updateRenderer](https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d) function generated for the code with pipe:



ä»å†…å­˜çš„è§’åº¦è€ƒè™‘ï¼Œä½ ä¸éœ€è¦åˆ›å»ºä¸€ä¸ªPipe classçš„å®ä¾‹ã€‚ä»ç¼–è¯‘æ—¶é—´è§’åº¦æ¥çœ‹ï¼Œç¼–è¯‘å™¨ä¸éœ€è¦èŠ±æ—¶é—´å»è§£æpipeçš„ç‰¹æœ‰è¯­æ³•å¹¶ç”Ÿæˆpipeçš„ç‰¹æœ‰è¾“å‡ºã€‚ä»è¿è¡Œæ—¶è§’åº¦çœ‹ï¼Œåœ¨æ¯æ¬¡æ‰§è¡Œ change detection æ—¶ï¼Œä½ çœå»äº†åœ¨ç»„ä»¶ä¸­ä½¿ç”¨async pipeæ—¶å‘ç”Ÿçš„ä¸€å †çš„å‡½æ•°è°ƒç”¨ã€‚è¿™é‡Œçš„ç¤ºä¾‹ä»£ç æ¼”ç¤ºäº† å½“ä»£ç ä¸­åŒ…å« pipeæ—¶ [updateRenderer](https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d) æ‰€ç”Ÿæˆçš„ä»£ç :

~~~js
function (_ck, _v) {
    var _co = _v.component;
    var currVal_0 = jit_unwrapValue_7(_v, 3, 0, asyncpipe.transform(_co.user)).name;
    _ck(_v, 3, 0, currVal_0);
}
~~~



As you can see, the code for the async pipe calls the `transform` method on the pipe instance to get the new value. The pipe is going to return the latest value it received from the subscription.

Compare it to the plain code generated for the manual approach:



æ­£å¦‚ä½ æ‰€è§ï¼Œasync pipe ä»£ç ä¸­æ¯ä¸ªpipeå®ä¾‹éƒ½è¦è°ƒç”¨ `transform` å‡½æ•°æ¥è·å–æ–°çš„å€¼ã€‚pipeå°†ä¼šè¿”å›ä»è®¢é˜…ï¼ˆsubscriptionï¼‰ä¸­è·å–çš„æœ€æ–°çš„å€¼ã€‚

å°† async pipe çš„ä»£ç ä¸æ‰‹åŠ¨æ–¹æ³•ç”Ÿæˆçš„ä»£ç ç›¸æ¯”ï¼š

~~~js
function(_ck,_v) {
    var _co = _v.component;
    var currVal_0 = _co.user.name;
    _ck(_v,3,0,currVal_0);
}
~~~



These are the functions executed by Angular when checking `B` component.

è¿™äº›äº‹ Angular æ£€æŸ¥ç»„ä»¶ `B` æ—¶æ‰€æ‰§è¡Œçš„å‡½æ•°ã€‚

### A few more interesting things

### ä¸€äº›æ›´æœ‰è¶£çš„äº‹

Unlike input bindings that perform shallow comparison, **the async pipe**implementation **doesnâ€™t perform comparison at all** (kudos to [Olena Horal](https://medium.com/@sharlatenok)for noticing that). It treats every new emission as an update even if it matches the previously emitted value. Hereâ€™s the implementation of the parent component `A` that emits the same object. Despite this fact, Angular still runs change detection for the component `B`:

ä¸ input bindings çš„æµ…æ¯”è¾ƒä¸åŒï¼Œ **async pipe ** çš„å®ç° **å®Œå…¨æ²¡æœ‰è¿›è¡Œå€¼æ¯”è¾ƒ** (æ„Ÿè°¢ [Olena Horal](https://medium.com/@sharlatenok) çš„æé†’)ã€‚

~~~typescript
export class AComponent {
    o = {name: 'A'};
    user = new BehaviorSubject(this.o);

    changeName() {
        this.user.next(this.o);
    }
}
~~~

It means that the component with the async pipe will be **marked for check every time a new value is emitted**. And Angular will check the component next time it runs change detection even if the value hasnâ€™t changed.



è¿™æ„å‘³ç€ä½¿ç”¨äº† async pipe çš„ç»„ä»¶**æ¯æ¬¡äº§ç”Ÿæ–°çš„å€¼éƒ½ä¼šè¢«æ ‡è®°æˆéœ€è¦è¢«æ£€æŸ¥**ã€‚ é‚£ä¹ˆæ— è®ºå€¼æ˜¯å¦å‘ç”Ÿæ”¹å˜ï¼ŒAngular åœ¨ä¸‹æ¬¡æ‰§è¡Œ change detection éƒ½å°†ä¼šå¯¹è¯¥ç»„ä»¶åšæ£€æŸ¥ã€‚

Where is this relevant? Well, in our case weâ€™re only interested in the property `name` from the `user` object because we use it in the template. We donâ€™t really care about the whole object and the fact that the reference to the object may change. If the name is the same we donâ€™t need to re-render the component. But you canâ€™t avoid that with the async pipe.

è¿™ä¸ä»€ä¹ˆç›¸å…³å‘¢ï¼Ÿåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªå…³å¿ƒ `user` å¯¹è±¡çš„ `name` å±æ€§ï¼Œå› ä¸ºæˆ‘ä»¬ä¼šåœ¨æ¨¡æ¿ä¸­ç”¨åˆ°å®ƒã€‚æˆ‘ä»¬å¹¶ä¸å…³å¿ƒè¿™æ•´ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”å®é™…ä¸Šè¯¥å¯¹è±¡çš„å¼•ç”¨å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚ä½†å¦‚æœ `name` å±æ€§äº‹ä¸€è‡´çš„ï¼Œæˆ‘ä»¬æ²¡æœ‰å¿…è¦å†æ¬¡æ¸²æŸ“ç»„ä»¶ã€‚ä½†æ˜¯ä½ ä½¿ç”¨ async pipe å°±æ— æ³•é¿å…äº†ã€‚



`NgDoCheck` is not without the problems on its own :) As the hook is only triggered if the parent component is checked, it wonâ€™t be triggered if one of its parent components uses `OnPush` strategy and is not checked during change detection. So you canâ€™t rely on it to trigger change detection when you receive a new value through a service. In this case, the solution I showed with putting `markForCheck` in the subscription callback is the way to go.

`NgDoCheck` æœ¬èº«ä¹Ÿæœ‰è¿™ä¸ªé—®é¢˜ :) ç”±äºè¯¥é’©å­å‡½æ•°åªæœ‰å½“çˆ¶ç»„ä»¶è¢«æ£€æŸ¥ä¹‹åæ‰ä¼šè§¦å‘ï¼Œè€Œå½“å…¶ä»»æ„ä¸€ä¸ªçˆ¶ç»„ä»¶ä½¿ç”¨äº† `OnPush` ç­–ç•¥ï¼Œå¹¶ä¸”æ²¡æœ‰åœ¨ change detection æ—¶è¿›è¡Œæ£€æŸ¥ï¼Œé‚£ä¹ˆè¿™ä¸ªé’©å­å‡½æ•°ä¹Ÿä¸ä¼šè¢«è§¦å‘ã€‚ æ‰€ä»¥å½“ä»æœåŠ¡ä¸­æ¥å—åˆ°æ–°å€¼æ—¶ï¼Œä½ å¹¶ä¸èƒ½ä¾èµ–ä»–æ¥è§¦å‘ change detectionã€‚ åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘æ‰€æ¼”ç¤ºçš„å°† `markForCheck` æ–¹æ³•æ”¾åœ¨subscriptionçš„å›è°ƒå‡½æ•°ä¸­æ˜¯æ­£ç¡®çš„è§£å†³æ–¹æ³•ã€‚

### Conclusion

### æ€»ç»“

Basically, manual comparison gives you more control over the check. You can define when the component needs to be checked. And this is the same as with many other toolsâ€Šâ€”â€Šmanual control gives you more flexibility, but you have to know what youâ€™re doing. And to acquire this knowledge, I encourage you to invest time and effort in learning and [reading sources](https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630).

æ€»çš„æ¥è¯´ï¼Œæ‰‹åŠ¨æ¯”è¾ƒè¿™ç§æ–¹å¼ç»™äº†ä½ æ›´å¯¹çš„æ§åˆ¶æƒå»åšæ£€æŸ¥ã€‚ä½ å¯ä»¥è‡ªå·±å®šä¹‰ç»„ä»¶åˆé€‚éœ€è¦è¢«æ£€æŸ¥ã€‚è¿™ä¸å¾ˆå¤šå…¶ä»–çš„å·¥å…·ä¸€è‡´â€”â€”æ‰‹åŠ¨æ§åˆ¶ç»™äº†ä½ æ›´å¤šçš„æŸ”æ€§ï¼Œä½†æ˜¯ä½ ä¹Ÿå¿…é¡»ä½ åˆ°ä½ æ­£åœ¨åšä»€ä¹ˆã€‚ä¸ºäº†è·å–ç›¸å…³çŸ¥è¯†ï¼Œæˆ‘é¼“åŠ±ä½ èŠ±ç‚¹æ—¶é—´å’Œç²¾åŠ›å»é˜…è¯»å­¦ä¹ ä¸‹[è¿™ç¯‡æ–‡ç« ](https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630)ã€‚

If youâ€™re concerned with how often `NgDoCheck` lifecycle hook is called or that itâ€™s going to be called more often than the pipeâ€™s `transform`â€Šâ€”â€Šdonâ€™t. First, I showed the solution above where you donâ€™t use the hook in the manual approach with asynchronous stream. Second, the hook will only be called when the parent component is checked. If the parent component is not checked, the hook is not called. And with regards to the pipe, because of the shallow check and changing references in the stream, youâ€™re going to have the same number of calls or even more with the `transform` method of the pipe.

å¦‚æœä½ å…³å¿ƒ `NgDoCheck` ç”Ÿå‘½å‘¨æœŸé’©å­å‡½æ•°è¢«è°ƒç”¨çš„é¢‘ç‡ï¼Œæˆ–è€…æ‹…å¿ƒå…¶è°ƒç”¨é¢‘ç‡è¦æ¯” pipe çš„  `transform`â€Š å‡½æ•°æ›´é«˜â€”â€”å®Œå…¨æ²¡å¿…è¦æ‹…å¿ƒã€‚é¦–å…ˆï¼Œä¹‹å‰æˆ‘å·²ç»å±•ç¤ºäº†ä½¿ç”¨ asynchronous streamï¼Œå¹¶ä¸”ä¸ä½¿ç”¨è¯¥é’©å­å‡½æ•°çš„æ‰‹åŠ¨æ–¹æ³•ã€‚å…¶æ¬¡ï¼Œè¯¥é’©å­å‡½æ•°åªä¼šåœ¨çˆ¶ç»„ä»¶è¢«æ£€æŸ¥åæ‰ä¼šè¢«è°ƒç”¨ã€‚å¦‚æœçˆ¶ç»„ä»¶æ²¡æœ‰è¢«æ£€æŸ¥ï¼Œè¯¥é’©å­å‡½æ•°æ˜¯ä¸ä¼šè¢«è°ƒç”¨çš„ã€‚å¹¶ä¸”ï¼Œå¯¹äºpipeè€Œè¨€ï¼Œå› ä¸ºæ˜¯åœ¨æµä¸­è¿›è¡Œæµ…æ¯”è¾ƒå’Œæ”¹å˜å¼•ç”¨ï¼Œpipe ä¸­ `transform` å‡½æ•°è¢«è°ƒç”¨çš„æ¬¡æ•°åº”è¯¥æ˜¯ä¸€è‡´ç”šè‡³æ˜¯æ›´å¤šçš„ã€‚

#### Want to learn more about change detection in Angular?

#### æƒ³è¦äº†è§£æ›´è¿‡å…³äº Angular ä¸­ change detection çš„ç›¸å…³çŸ¥è¯†ï¼Ÿ

Start with [These 5 articles will make you an Angular Change Detection expert](https://blog.angularindepth.com/these-5-articles-will-make-you-an-angular-change-detection-expert-ed530d28930). This series is a must-read if you want to have a solid grasp of the change detection mechanism in Angular. Each article builds upon the information explained in the preceding one and goes from high-level overview down to implementation details with references to the sources.



ä»è¿™5ç¯‡æ–‡ç« å…¥æ‰‹ä¼šè®©ä½ æˆä¸ºAngular Change Detection çš„ä¸“å®¶ã€‚å¦‚æœä½ æƒ³è¦ç‰¢å›ºæŒæ¡ Angular ä¸­ change detection çš„æœºåˆ¶ï¼Œé‚£ä¹ˆè¿™ä¸€ç³»åˆ—çš„æ–‡ç« æ˜¯å¿…è¯»çš„ã€‚æ¯ä¸€ç¯‡æ–‡ç« éƒ½æ˜¯åŸºäºå‰ä¸€ç¯‡æ–‡ç« ä¸­æ‰€è§£é‡Šçš„ç›¸å…³ä¿¡æ¯ï¼Œä¸Šè‡³é«˜å±‚æ¬¡çš„æ¦‚è¿°ï¼Œä¸‹è‡³å…·ä½“çš„å®ç°ç»†èŠ‚ï¼Œå¹¶ä¸”éƒ½é™„æœ‰ç›¸å…³æºä»£ç ã€‚

### For more insights follow me on [Twitter](https://twitter.com/maxim_koretskyi) and on [Medium](https://medium.com/@maxim.koretskyi).

æƒ³è¦äº†è§£æ›´å¤šï¼Œè¯·è¯·åœ¨ [Twitter](https://twitter.com/maxim_koretskyi) å’Œ [Medium](https://medium.com/@maxim.koretskyi)ä¸Šå…³æ³¨æˆ‘ã€‚