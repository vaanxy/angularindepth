> 原文链接：[The difference between NgDoCheck and AsyncPipe in OnPush components](https://blog.angularindepth.com/the-difference-between-ngdocheck-and-asyncpipe-in-onpush-components-4918ec4b29d4)
>
> 原技术博文由`Max Koretskyi`撰写发布，他目前于[ag-Grid](https://angular-grid.ag-grid.com/?utm_source=medium&utm_medium=blog&utm_campaign=angularcustom)担任开发者职位
>
> 译者：[vaanxy](https://github.com/vaanxy)；校对者：暂无



# On Push 组件中NgDoCheck 与 AsyncPipe 的不同之处

一份关于在Angular中手动控制 change detection 的深度指南



![img](https://cdn-images-1.medium.com/max/1600/1*QGZXvzfMNr2LLtQqOlf5XQ.jpeg)

------

本博文是 [对 Shai 推文](https://twitter.com/shai_reznik/status/1054868497363283968) 问题的回复。 

He asks whether it makes sense to use `NgDoCheck` lifecycle hook to manually compare values instead of using the recommend approach with the `async` pipe.

他想知道何时使用 `NgDoCheck` 这一生命周期钩子函数来手动比较值的变化，而非使用推荐的 `async` 管道方法。

 That’s a very good question that requires a lot of understanding of how things work under the hood: change detection, pipes and lifecycle hooks. That’s where I come in 😎.

这是个很棒的问题，回答这个问题需要了解很多关于 change detection, pipes 以及 lifecycle hooks 相关知识背后的工作原理。我就是为此而来的😎。

In this article I’m going to show you how to manually work with change detection. These techniques give you a finer control over the comparisons performed automatically by Angular for input bindings and async values checks. Once we have this knowledge, I’ll share with you my thoughts on the performance impact of these solutions.



本文我将为大家演示如何去手动操作 change detection。相比 Angular 自动地处理比较 input bindings 以及 async values checks，掌握下文将演示的技巧之后，将能帮助你更好的去控制这些内容。

一旦我们掌握了这些知识，我将会为大家分享一些关于这些解决方案对应用性能影响的个人观点。



> 我在 [ag-Grid](https://angular-grid.ag-grid.com/?utm_source=medium&utm_medium=blog&utm_campaign=angularcustom) 担任开发者职位。如果你对 data grids 很感兴趣，或者你在寻找Angular 中 data grid 的终极解决方案，跟着本指南"[Get started with Angular grid in 5 minutes](http://blog.ag-grid.com/index.php/2018/08/13/get-started-with-angular-grid-in-5-minutes/?utm_source=medium&utm_medium=blog&utm_campaign=getstartedangular)"来尝试下ag-grid吧。如果你们有任何问题，我很高兴为大家解答。 [**敬请关注我的最新动态!**](https://twitter.com/maxim_koretskyi)



让我们开始吧！

#### **OnPush components**

#### OnPush	组件

In Angular, we have a very common optimization technique that requires adding the `ChangeDetectionStrategy.OnPush` to a component’s decorator. Suppose we have a simple hierarchy of two components like this:

在Angular中，我们有一个非常常见的优化技巧，那就是在组件装饰器中添加上 `ChangeDetectionStrategy.OnPush`。比如我们有如下两个结构简单的组件：

~~~typescript
@Component({
    selector: 'a-comp',
    template: `
        <span>I am A component</span>
        <b-comp></b-comp>
    `
})
export class AComponent {}

@Component({
    selector: 'b-comp',
    template: `<span>I am B component</span>`
})
export class BComponent {}
~~~

With this setup, Angular runs change detection always for both `A` and `B`components every single time. If we now add the `OnPush` strategy for the `B`component:

按照上述方法进行配置，Angular每次都会对组件 `A` 和组件 `B` 进行change detection。如果我们现在为组件`B`添加`OnPush`策略: 

~~~

Angular will run change detection for the `B` component **only if its input bindings have changed**. Since at this point it doesn’t have any bindings, the component will ever only be checked once during the bootstrap.

Angular **仅会在组件 `B` 的 input bindings 发生变化时**才对其进行 change detection。尽管现在组件B还没有任何 bindings，组件仅仅会在启动的时候被检查一次。

#### Triggering change detection manually

Is there a way to force change detection on the component `B`? Yes, we can inject `changeDetectorRef` and use its method `markForCheck` to indicate for Angular that this component needs to be checked. And [since the NgDoCheck hook will still be triggered for B component](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5), that’s where we should call the method:

#### 手动触发change detection

我们是否能够强行对组件 `B` 进行change detection? 当然，我们可以通过注入 `changeDetectorRef`  并调用其 `markForCheck` 方法来示意 Angular 这个组件需要被检查一下。并且 [由于组件 B NgDoCheck 钩子函数仍会被触发](https://blog.angularindepth.com/if-you-think-ngdocheck-means-your-component-is-being-checked-read-this-article-36ce63a3f3e5)，因此我们应当在该钩子函数里调用 `markForCheck` 方法。

​~~~typescript
@Component({
    selector: 'b-comp',
    template: `<span>I am B component</span>`,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    constructor(private cd: ChangeDetectorRef) {}

    ngDoCheck() {
        this.cd.markForCheck();
    }
}
~~~

Now, the component `B` will always be checked when Angular checks the parent `A` component. Let’s now see where we can use it.

现在，当Angular对组件 `A` 进行检查的时候，组件 `B` 也总是会被检查。 现在让我们看看我们能在哪儿使用它。

#### Input bindings

I told you that Angular only runs change detection for `OnPush` components when bindings change. So let’s see the example with input bindings. Suppose we have an object that is passed down from the parent component through the inputs:

刚才和大家说过，对于 `OnPush` 组件而言，Angular仅在 bindings 发生变化的时候才执行 change detection。让我们来看一下  input bindings 的例子。假设我们有一个对象是从父组件中通过 inputs 传递进来的：



~~~typescript

@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{user.name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input() user;
}
~~~



In the parent component `A` we define the object and also implement the `changeName` method that updates the name of the object when a button is clicked:

在其父组件 `A` 中，我们定义了这个对象，同时还是实现了  `changeName`  方法，当鼠标点击按钮时来更新对象的`name`属性：

~~~typescript
@Component({
    selector: 'a-comp',
    template: `
        <span>I am A component</span>
        <button (click)="changeName()">Trigger change detection</button>
        <b-comp [user]="user"></b-comp>
    `
})
export class AComponent {
    user = {name: 'A'};

    changeName() {
        this.user.name = 'B';
    }
}
~~~

If you now [run this example](https://stackblitz.com/edit/angular-kq26qe), after the first change detection you’re going to see the user’s name printed:

```
User name: A
```



如果你 [运行这个例子](https://stackblitz.com/edit/angular-kq26qe)，在首次 change detection 后，你将会看到用户的`name`属性被打印了出来：

~~~User name: A~~~
User name: A
~~~

But when we click on the button and change the name in the callback:

但当我们点击按钮时，并在其回调函数中改变`name`属性的值：

```js
changeName() {
    this.user.name = 'B';
}
```

the name is **not updated** on the screen. And we know why, that’s because Angular performs shallow comparison for the input parameters and the reference to the `user` object hasn’t changed. So how can we fix this?

`name`属性并**没有在屏幕上更新**。我们也知道是为什么，Angular对于传入参数而言执行的是浅比对，`user` 对象的引用并没有发生变化。那么我们该怎么修复这个问题呢？

Well, we can manually check the name and trigger change detection when we detect the difference:

我们只需要手动检查比对 `name` 属性，当发现 `name` 的值发生变化时手动触发 change detection：



~~~typescript
@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{user.name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input() user;
    previousName = '';

    constructor(private cd: ChangeDetectorRef) {}

    ngDoCheck() {
        if (this.previousName !== this.user.name) {
            this.previousName = this.user.name;
            this.cd.markForCheck();
        }
    }
}
~~~



If you now [run this code](https://stackblitz.com/edit/angular-8dkwct), you’re going to see the name updated on the screen.

现在再[执行这段代码](https://stackblitz.com/edit/angular-8dkwct)，你会发现屏幕上的名字被更新了。

#### Asynchronous updates

#### 异步更新

Now, let’s make our example a bit more complex. We’re going to introduce an RxJs based service that emits updates asynchronously. This is similar to what you have in NgRx based architectures. I’m going to use a `BehaviorSubject` as a source of values because I need to start the stream with an initial value:

现在，让我们的例子更复杂些。我们将引入基于RxJS的服务，并通过他来实现异步更新。这和NgRx的架构师类似的。我将使用 `BehaviorSubject` 作为数据源，因为我想要启动流的时候能有一个初始值：

~~~typescript

@Component({
    selector: 'a-comp',
    template: `
        <span>I am A component</span>
        <button (click)="changeName()">Trigger change detection</button>
        <b-comp [user]="user"></b-comp>
    `
})
export class AComponent {
    stream = new BehaviorSubject({name: 'A'});
    user = this.stream.asObservable();

    changeName() {
        this.stream.next({name: 'B'});
    }
}
~~~



So we receive this stream of `user` objects in the child component. We need to subscribe to the stream and check if the values are updated. And the common approach to doing that is to use [Async pipe](https://angular.io/api/common/AsyncPipe).



所以我们可以在子组件中接受到该  `user`  对象流。我们需要订阅这个流，并检查值是否被更新了。最常用的方法就是使用 [Async pipe](https://angular.io/api/common/AsyncPipe)。

#### Async pipe

So here’s the implementation of the child `B` component:

下面是子组件 `B` 的实现：

~~~typescript

@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{(user | async).name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input() user;
}
~~~

[Here’s the demo](https://stackblitz.com/edit/angular-q8n3qj). But is there another way that doesn't use the pipe?

[这里是 demo](https://stackblitz.com/edit/angular-q8n3qj)。但有没有不使用管道的方法呢？



#### Manual check and change detection

#### 手动检查以及 change detection

Yes, we can check the value manually and trigger change detection if needed. Just as with the examples in the beginning, we can use `NgDoCheck` lifecycle hook for that:



是的，我们可以手动检查值的变化并在需要的时候触发 change detection。就和最一开始的示例一样，我们可以像这样使用 `NgDoCheck` 生命周期钩子函数：

~~~typescript
@Component({
    selector: 'b-comp',
    template: `
        <span>I am B component</span>
        <span>User name: {{user.name}}</span>
    `,
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class BComponent {
    @Input('user') user$;
    user;
    previousName = '';

    constructor(private cd: ChangeDetectorRef) {}

    ngOnInit() {
        this.user$.subscribe((user) => {
            this.user = user;
        })
    }

    ngDoCheck() {
        if (this.previousName !== this.user.name) {
            this.previousName = this.user.name;
            this.cd.markForCheck();
        }
    }
}
~~~



You can [play with it here](https://stackblitz.com/edit/angular-4xuug1).

你可以[在这儿进行尝试](https://stackblitz.com/edit/angular-4xuug1)。

Ideally, though, we would want to move our comparison and update logic from `NgDoCheck` and put it into the subscription callback, because that’s when the new value will be available:

理想的情况下，尽管，我们想要将比较与更新的逻辑从`NgDoCheck`移至subscription的回调函数中，因为，我们是从那里获取到新的值的：



~~~typescript
export class BComponent {
    @Input('user') user$;
    user = {name: null};

    constructor(private cd: ChangeDetectorRef) {}

    ngOnInit() {
        this.user$.subscribe((user) => {
            if (this.user.name !== user.name) {
                this.cd.markForCheck();
                this.user = user;
            }
        })
    }
}
~~~



<iframe width="700" height="250" data-src="/media/09199c5fb82c9e1bc3291f48299511eb?postId=4918ec4b29d4" data-media-id="09199c5fb82c9e1bc3291f48299511eb" data-thumbnail="https://i.embed.ly/1/image?url=https%3A%2F%2Favatars3.githubusercontent.com%2Fu%2F6124091%3Fs%3D400%26v%3D4&amp;key=a19fcc184b9711e1b4764040d3dc5c07" class="progressiveMedia-iframe js-progressiveMedia-iframe" allowfullscreen="" frameborder="0" src="https://blog.angularindepth.com/media/09199c5fb82c9e1bc3291f48299511eb?postId=4918ec4b29d4" style="display: block; position: absolute; margin: auto; max-width: 100%; box-sizing: border-box; transform: translateZ(0px); top: 0px; left: 0px; width: 700px; height: 373px;"></iframe>

[在这儿进行尝试](https://stackblitz.com/edit/angular-lvtfve).

What’s interesting is that it’s exactly what the [Async pipe is doing under the hood](https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139):

但有趣的是，这也正是 [Async pipe背后的工作原理](https://github.com/maximusk/angular/blob/725bae1921cfcdcf5a5b0c35252c632198d1a7a4/packages/common/src/pipes/async_pipe.ts#L139):



~~~typescript
@Pipe({name: 'async', pure: false})
export class AsyncPipe implements OnDestroy, PipeTransform {
  constructor(private _ref: ChangeDetectorRef) {}

  transform(obj: ...): any {
    ...
    this._subscribe(obj);

    ...
    if (this._latestValue === this._latestReturnedValue) {
      return this._latestReturnedValue;
    }

    this._latestReturnedValue = this._latestValue;
    return WrappedValue.wrap(this._latestValue);
  }

  private _subscribe(obj): void {
    ...
    this._strategy.createSubscription(
        obj, (value: Object) => this._updateLatestValue(obj, value));
  }

  private _updateLatestValue(async: any, value: Object): void {
    if (async === this._obj) {
      this._latestValue = value;
      this._ref.markForCheck();
    }
  }
}
~~~

------

### So which solution is faster?

#### 那个解决方案更快呢？

So now that we know how we can use manual change detection instead of the async pipe, let’s answer the question we started with. Who’s faster?



既然现在我们知道如何手动执行 change detection 来替代 async pipe，让我们来回答一下最一开始的问题，哪一种方式更快？

Well, it depends on how you compare them, but with everything else being equal, manual approach is going to be faster. I don’t think though that the difference will be tangible. Here are just a few examples why manual approach can be faster. 

嗯，这取决于你怎么比较他们，在其他条件都一样时，手动方法会更快，尽管我不认为能看出明显的区别。一下几个例子会说明为什么手动方法更快。

In terms of memory you don’t need to create an instance of a Pipe class. In terms of compilation time the compiler doesn’t have to spend time parsing pipe specific syntax and generating pipe specific output. In terms of runtime, you save yourself a couple of function calls for each change detection run on the component with async pipe. Here’s for example the code for the [updateRenderer](https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d) function generated for the code with pipe:



从内存的角度考虑，你不需要创建一个Pipe class的实例。从编译时间角度来看，编译器不需要花时间去解析pipe的特有语法并生成pipe的特有输出。从运行时角度看，在每次执行 change detection 时，你省去了在组件中使用async pipe时发生的一堆的函数调用。这里的示例代码演示了 当代码中包含 pipe时 [updateRenderer](https://blog.angularindepth.com/the-mechanics-of-dom-updates-in-angular-3b2970d5c03d) 所生成的代码:

~~~js
function (_ck, _v) {
    var _co = _v.component;
    var currVal_0 = jit_unwrapValue_7(_v, 3, 0, asyncpipe.transform(_co.user)).name;
    _ck(_v, 3, 0, currVal_0);
}
~~~



As you can see, the code for the async pipe calls the `transform` method on the pipe instance to get the new value. The pipe is going to return the latest value it received from the subscription.

Compare it to the plain code generated for the manual approach:



正如你所见，async pipe 代码中每个pipe实例都要调用 `transform` 函数来获取新的值。pipe将会返回从订阅（subscription）中获取的最新的值。

将 async pipe 的代码与手动方法生成的代码相比：

~~~js
function(_ck,_v) {
    var _co = _v.component;
    var currVal_0 = _co.user.name;
    _ck(_v,3,0,currVal_0);
}
~~~



These are the functions executed by Angular when checking `B` component.

这些事 Angular 检查组件 `B` 时所执行的函数。

### A few more interesting things

### 一些更有趣的事

Unlike input bindings that perform shallow comparison, **the async pipe**implementation **doesn’t perform comparison at all** (kudos to [Olena Horal](https://medium.com/@sharlatenok)for noticing that). It treats every new emission as an update even if it matches the previously emitted value. Here’s the implementation of the parent component `A` that emits the same object. Despite this fact, Angular still runs change detection for the component `B`:

与 input bindings 的浅比较不同， **async pipe ** 的实现 **完全没有进行值比较** (感谢 [Olena Horal](https://medium.com/@sharlatenok) 的提醒)。

~~~typescript
export class AComponent {
    o = {name: 'A'};
    user = new BehaviorSubject(this.o);

    changeName() {
        this.user.next(this.o);
    }
}
~~~

It means that the component with the async pipe will be **marked for check every time a new value is emitted**. And Angular will check the component next time it runs change detection even if the value hasn’t changed.



这意味着使用了 async pipe 的组件**每次产生新的值都会被标记成需要被检查**。 那么无论值是否发生改变，Angular 在下次执行 change detection 都将会对该组件做检查。

Where is this relevant? Well, in our case we’re only interested in the property `name` from the `user` object because we use it in the template. We don’t really care about the whole object and the fact that the reference to the object may change. If the name is the same we don’t need to re-render the component. But you can’t avoid that with the async pipe.

这与什么相关呢？在我们的例子中，我们只关心 `user` 对象的 `name` 属性，因为我们会在模板中用到它。我们并不关心这整个对象，并且实际上该对象的引用可能会发生变化。但如果 `name` 属性事一致的，我们没有必要再次渲染组件。但是你使用 async pipe 就无法避免了。



`NgDoCheck` is not without the problems on its own :) As the hook is only triggered if the parent component is checked, it won’t be triggered if one of its parent components uses `OnPush` strategy and is not checked during change detection. So you can’t rely on it to trigger change detection when you receive a new value through a service. In this case, the solution I showed with putting `markForCheck` in the subscription callback is the way to go.

`NgDoCheck` 本身也有这个问题 :) 由于该钩子函数只有当父组件被检查之后才会触发，而当其任意一个父组件使用了 `OnPush` 策略，并且没有在 change detection 时进行检查，那么这个钩子函数也不会被触发。 所以当从服务中接受到新值时，你并不能依赖他来触发 change detection。 在本例中，我所演示的将 `markForCheck` 方法放在subscription的回调函数中是正确的解决方法。

### Conclusion

### 总结

Basically, manual comparison gives you more control over the check. You can define when the component needs to be checked. And this is the same as with many other tools — manual control gives you more flexibility, but you have to know what you’re doing. And to acquire this knowledge, I encourage you to invest time and effort in learning and [reading sources](https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630).

总的来说，手动比较这种方式给了你更对的控制权去做检查。你可以自己定义组件合适需要被检查。这与很多其他的工具一致——手动控制给了你更多的柔性，但是你也必须你到你正在做什么。为了获取相关知识，我鼓励你花点时间和精力去阅读学习下[这篇文章](https://blog.angularindepth.com/level-up-your-reverse-engineering-skills-8f910ae10630)。

If you’re concerned with how often `NgDoCheck` lifecycle hook is called or that it’s going to be called more often than the pipe’s `transform` — don’t. First, I showed the solution above where you don’t use the hook in the manual approach with asynchronous stream. Second, the hook will only be called when the parent component is checked. If the parent component is not checked, the hook is not called. And with regards to the pipe, because of the shallow check and changing references in the stream, you’re going to have the same number of calls or even more with the `transform` method of the pipe.

如果你关心 `NgDoCheck` 生命周期钩子函数被调用的频率，或者担心其调用频率要比 pipe 的  `transform`  函数更高——完全没必要担心。首先，之前我已经展示了使用 asynchronous stream，并且不使用该钩子函数的手动方法。其次，该钩子函数只会在父组件被检查后才会被调用。如果父组件没有被检查，该钩子函数是不会被调用的。并且，对于pipe而言，因为是在流中进行浅比较和改变引用，pipe 中 `transform` 函数被调用的次数应该是一致甚至是更多的。

#### Want to learn more about change detection in Angular?

#### 想要了解更过关于 Angular 中 change detection 的相关知识？

Start with [These 5 articles will make you an Angular Change Detection expert](https://blog.angularindepth.com/these-5-articles-will-make-you-an-angular-change-detection-expert-ed530d28930). This series is a must-read if you want to have a solid grasp of the change detection mechanism in Angular. Each article builds upon the information explained in the preceding one and goes from high-level overview down to implementation details with references to the sources.



从这5篇文章入手会让你成为Angular Change Detection 的专家。如果你想要牢固掌握 Angular 中 change detection 的机制，那么这一系列的文章是必读的。每一篇文章都是基于前一篇文章中所解释的相关信息，上至高层次的概述，下至具体的实现细节，并且都附有相关源代码。

### For more insights follow me on [Twitter](https://twitter.com/maxim_koretskyi) and on [Medium](https://medium.com/@maxim.koretskyi).

想要了解更多，请请在 [Twitter](https://twitter.com/maxim_koretskyi) 和 [Medium](https://medium.com/@maxim.koretskyi)上关注我。